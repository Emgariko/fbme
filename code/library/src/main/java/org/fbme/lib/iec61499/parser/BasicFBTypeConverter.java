package org.fbme.lib.iec61499.parser;

/*Generated by MPS */

import org.fbme.lib.common.StringIdentifier;
import org.fbme.lib.iec61499.declarations.BasicFBTypeDeclaration;
import org.fbme.lib.st.STFactory;
import org.fbme.lib.st.expressions.*;
import org.jetbrains.annotations.Nullable;
import org.fbme.lib.common.Identifier;
import org.jdom.Element;
import org.fbme.lib.iec61499.ecc.ECC;

import java.util.List;

import org.fbme.lib.iec61499.ecc.StateDeclaration;
import org.fbme.lib.iec61499.ecc.StateAction;
import org.fbme.lib.iec61499.ecc.StateTransition;
import org.fbme.lib.iec61499.ecc.ECTransitionCondition;

import java.util.Objects;

import org.fbme.lib.iec61499.declarations.AlgorithmDeclaration;
import org.fbme.lib.iec61499.declarations.AlgorithmBody;
import org.fbme.lib.iec61499.declarations.AlgorithmLanguage;

public final class BasicFBTypeConverter extends DeclarationConverterBase<BasicFBTypeDeclaration> {

  public BasicFBTypeConverter(ConverterArguments arguments) {
    super(arguments);
  }

  @Override
  protected BasicFBTypeDeclaration extractDeclarationBody(@Nullable Identifier identifier) {
    assert myElement != null;

    BasicFBTypeDeclaration fbtd = myFactory.createBasicFBTypeDeclaration(identifier);
    Element basicFbElement = myElement.getChild("BasicFB");

    new FBInterfaceConverter(this, fbtd).extractInterface();
    new FBInterfaceAdaptersConverter(this, fbtd).extractAdapters();
    ParameterDeclarationConverter.extractAll(with(basicFbElement.getChild("InternalVars")), fbtd.getInternalVariables());

    Element eccElement = basicFbElement.getChild("ECC");
    if (eccElement != null) {
      ECC ecc = fbtd.getEcc();
      List<Element> ecStateElements = eccElement.getChildren("ECState");
      for (Element ecStateElement : ecStateElements) {
        ecc.getStates().add(new StateConverter(with(ecStateElement)).extract());
      }
      List<Element> ecTransitionElements = eccElement.getChildren("ECTransition");
      for (Element ecTransitionElement : ecTransitionElements) {
        ecc.getTransitions().add(convertEcTransition(ecTransitionElement, fbtd));
      }
    }

    List<Element> algorithmElements = basicFbElement.getChildren("Algorithm");
    for (Element algorithmElement : algorithmElements) {
      fbtd.getAlgorithms().add(new AlgorithmConverter(with(algorithmElement)).extract());
    }

    return fbtd;
  }

  private static class StateConverter extends DeclarationConverterBase<StateDeclaration> {

    public StateConverter(ConverterArguments arguments) {
      super(arguments);
    }

    @Override
    protected StateDeclaration extractDeclarationBody(@Nullable Identifier identifier) {
      assert myElement != null;

      StateDeclaration state = myFactory.createStateDeclaration(identifier);
      List<Element> ecActionElements = myElement.getChildren("ECAction");
      for (Element ecActionElement : ecActionElements) {
        StateAction action = myFactory.createStateAction();
        String algorithmName = ecActionElement.getAttributeValue("Algorithm");
        String eventName = ecActionElement.getAttributeValue("Output");
        if ((algorithmName != null && algorithmName.length() > 0)) {
          action.getAlgorithm().setTargetName(algorithmName);
        }
        if ((eventName != null && eventName.length() > 0)) {
          action.getEvent().setFQName(eventName);
        }
        state.getActions().add(action);
      }
      state.setX((int) Float.parseFloat(myElement.getAttributeValue("x")));
      state.setY((int) Float.parseFloat(myElement.getAttributeValue("y")));

      return state;
    }
  }

  private StateTransition convertEcTransition(Element ecTransitionElement, BasicFBTypeDeclaration fbtd) {
    StateTransition transition = myFactory.createStateTransition();
    transition.getSourceReference().setTargetName(ecTransitionElement.getAttributeValue("Source"));
    transition.getTargetReference().setTargetName(ecTransitionElement.getAttributeValue("Destination"));

    parseCondition(transition.getCondition(), ecTransitionElement.getAttributeValue("Condition"), fbtd);
    transition.setCenterX((int) Float.parseFloat(ecTransitionElement.getAttributeValue("x")));
    transition.setCenterY((int) Float.parseFloat(ecTransitionElement.getAttributeValue("y")));

    return transition;
  }

  private void parseCondition(ECTransitionCondition condition, String rawCondition, BasicFBTypeDeclaration fbtd) {
    rawCondition = rawCondition.trim();
    if (Objects.equals(rawCondition, "1")) {
      return;
    }
    int openBracketIndex = rawCondition.indexOf('[');
    int closeBracketIndex = rawCondition.lastIndexOf(']');
    if (openBracketIndex == -1) {
      Expression guardCondition = STConverter.parseExpression(myStFactory, unescapeXML(rawCondition));
      TransitionImportChecker checker = new TransitionImportChecker(myStFactory, fbtd);
      checker.checkTransition(guardCondition);
      if (checker.satisfies()) {
        String eventName = checker.getEventName();
        if (eventName.length() > 0) {
          condition.getEventReference().setFQName(eventName);
        }
        condition.setGuardCondition(checker.getNewGuardCondition());
      } else {
        condition.getEventReference().setFQName(rawCondition);
      }
      return;
    }
    if (closeBracketIndex != rawCondition.length() - 1) {
      throw new IllegalArgumentException("Malformed transition condition");
    }
    if (openBracketIndex > 0) {
      condition.getEventReference().setFQName(rawCondition.substring(0, openBracketIndex));
    }
    String guardConditionText = unescapeXML(rawCondition.substring(openBracketIndex + 1, closeBracketIndex));
    condition.setGuardCondition(STConverter.parseExpression(myStFactory, guardConditionText));
  }

  private static class AlgorithmConverter extends DeclarationConverterBase<AlgorithmDeclaration> {

    public AlgorithmConverter(ConverterArguments arguments) {
      super(arguments);
    }

    @Override
    protected AlgorithmDeclaration extractDeclarationBody(@Nullable Identifier identifier) {
      AlgorithmDeclaration algorithmDeclaration = myFactory.createAlgorithmDeclaration(identifier);
      Element stBodyElement = myElement.getChild("ST");
      if (stBodyElement != null) {
        AlgorithmBody.ST st = myFactory.createAlgorithmBody(AlgorithmLanguage.ST);
        algorithmDeclaration.setBody(st);
        String stText = unescapeXML(stBodyElement.getAttributeValue("Text"));
        if (stText != null) {
          st.getStatements().addAll(STConverter.parseStatementList(myStFactory, stText));
        }
      }
      Element otherBodyElement = myElement.getChild("Other");
      if (otherBodyElement != null) {
        AlgorithmBody.Unknown unknown = myFactory.createAlgorithmBody(AlgorithmLanguage.unknown(otherBodyElement.getAttributeValue("Language")));
        algorithmDeclaration.setBody(unknown);
        String text = unescapeXML(otherBodyElement.getAttributeValue("Text"));
        if (text != null) {
          unknown.setText(text);
        }
      }
      return algorithmDeclaration;
    }
  }

  private class TransitionImportChecker {
    private boolean satisfy;
    private String eventName;
    private Expression newGuardCondition;
    protected final STFactory myStFactory;
    protected final BasicFBTypeDeclaration fbtd;

    TransitionImportChecker(STFactory myStFactory, BasicFBTypeDeclaration fbtd) {
      this.satisfy = false;
      this.eventName = "";
      this.newGuardCondition = null;
      this.myStFactory = myStFactory;
      this.fbtd = fbtd;
    }

    private void setDefaultBraces(Expression guardCondition) {
      this.eventName = "";
      this.newGuardCondition = guardCondition;
      this.satisfy = true;
    }

    public void checkTransition(Expression guardCondition) {
      if (guardCondition instanceof VariableReference) {
        String variableName = ((StringIdentifier) (((VariableReference) guardCondition).getReference().getIdentifier())).getValue();
        if (this.fbtd.getInputParameters().stream().anyMatch(x -> x.getName().equals(variableName))) {
          setDefaultBraces(guardCondition);
          return;
        }
      }
      if (guardCondition instanceof ParenthesisExpression) {
        checkTransition(((ParenthesisExpression) guardCondition).getInnerExpression());
        if (this.satisfies()) {
          this.newGuardCondition = guardCondition;
        }
        return;
      }
      if (guardCondition instanceof UnaryExpression) {
        setDefaultBraces(guardCondition);
        return;
      }
      if (guardCondition instanceof BinaryExpression) {
        BinaryExpression binaryExpression = (BinaryExpression) guardCondition;
        switch (binaryExpression.getOperation()) {
          case AND:
          case OR:
          case XOR: {
            Expression leftExpression = binaryExpression.getLeftExpression();
            if (leftExpression instanceof VariableReference) {
              String variableName = ((StringIdentifier) (((VariableReference) leftExpression).getReference().getIdentifier())).getValue();
              if (this.fbtd.getInputEvents().stream().anyMatch(x -> x.getName().equals(variableName))) {
                this.eventName = variableName;
                this.newGuardCondition = binaryExpression.getRightExpression();
                this.satisfy = true;
                return;
              }
            }
            setDefaultBraces(guardCondition);
            return;
          }
          case EQ:
          case GT:
          case GTE:
          case LT:
          case LTE:
          case NEQ: {
            setDefaultBraces(guardCondition);
            return;
          }
          default: {
            return;
          }
        }
      }
      satisfy = false;
    }

    public boolean satisfies() {
      return satisfy;
    }

    public String getEventName() {
      return eventName;
    }

    public Expression getNewGuardCondition() {
      return newGuardCondition;
    }
  }
}
